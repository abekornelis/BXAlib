.*                                                                      00000100
.* This macro is free software; you can redistribute it and/or modify   00000200
.* it under the terms of the GNU General Public License as published by 00000300
.* the Free Software Foundation; either version 2 of the License        00000400
.* or (at your option) any later version.                               00000500
.* The license text is available at the following internet addresses:   00000600
.* - http://www.bixoft.com/english/gpl.htm                              00000700
.* - http://fsf.org                                                     00000800
.* - http://opensource.org                                              00000900
.*                                                                      00001000
.* This macro is distributed in the hope that it will be useful,        00001100
.* but WITHOUT ANY WARRANTY; without even the implied warranty of       00001200
.* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                 00001300
.* See the GNU General Public License for more details.                 00001400
.*                                                                      00001500
.* You should have received a copy of the GNU General Public License    00001600
.* along with this program; if not, write to either of the following:   00001700
.* the Free Software Foundation, Inc.      B.V. Bixoft                  00001800
.* 59 Temple Place, Suite 330              Rogge 9                      00001900
.* Boston, MA 02111-1307                   7261 JA Ruurlo               00002000
.* United States of America                The Netherlands              00002100
.*                                                                      00002200
.*                                         e-mail: bixoft@bixoft.nl     00002300
.*                                         phone : +31-6-22755401       00002400
.*                                                                      00002500
.********************************************************************** 00010000
.*                                                                      00020000
.* Bixoft eXtended Assembly language                                    00030000
.* Licensed material - Property of B.V. Bixoft                          00040000
.*                                                                      00050000
.* This macro can be licensed or used on an as-is basis.                00060000
.* No warranty, neither implicit nor explicit, is given.                00070000
.* It remains your own responsibility to ensure the correct             00080000
.* working of any program using this macro.                             00090000
.*                                                                      00100000
.* Suggestions for improvement are always welcome at                    00110000
.* http://www.bixoft.com  or mail to  bixoft@bixoft.nl                  00120000
.*                                                                      00130000
.* (C) Copyright B.V. Bixoft, 1999                                      00140000
.********************************************************************** 00150000
         MACRO                                                          00160000
.*                                                                      00170000
.* This macro generates code for exiting the active module              00180000
.*                                                                      00190000
&LABEL   RETRN &RC=0,                  * Returncode, (reg), or *       *00200000
               &REASON=,               * Reasoncode, (reg), or *       *00210000
               &RETPTR=,               * Return ptr value, (reg), or * *00220000
               &WORKAREA=FREE,         * FREE or NOFREE                *00230000
               &INLINE=YES             * YES or NO                      00240000
.*                                                                      00250000
.* &RC   specifies the returncode. Specification of * equals to (R15)   00260000
.*       If omitted a returncode of 0 will be generated by default.     00270000
.* &REASON specifies the reasoncode. Specification of * equals to (R0)  00280000
.*         If omitted, R0 will be restored to the contents at entry.    00290000
.* &RETPTR specifies a pointer value to be returned in R1.              00300000
.*         Specification of * equals to (R1).                           00310000
.*         If omitted, R1 will be restored to the contents at entry.    00320000
.* &WORKAREA specifies whether or not the area allocated by PGM         00330000
.*           is to be released.                                         00340000
.* &INLINE if specified as YES, a branch will be generated to an        00350000
.*         out-of-line routine which performs the requested function.   00360000
.*         if specified as NO the required out-of-line routine will     00370000
.*         be generated. INLINE=NO should be specified only by the END  00380000
.*         macro.                                                       00390000
.*                                                                      00400000
.********************************************************************** 00401001
.*                                                                      00402001
.*       IMPORTANT NOTICE                                               00403001
.*       ========= ======                                               00404001
.*                                                                      00405001
.* Code below checks whether 'USER' accepted the terms and conditions   00406001
.* of the license for the BXA macro library. This code is to be treated 00407001
.* as part of the Copyright Notice and therefore may not be changed     00408001
.* or disabled in any way.                                              00409001
.*                                                                      00409101
.********************************************************************** 00409201
         GBLA  &BXA_RC                 * Returncode from CHKLIC         00409301
         CHKLIC RETRN                  * Check license acceptance       00409401
         AIF   (&BXA_RC NE 0).MEND                                      00409502
.********************************************************************** 00409601
.*                                                                      00409701
.* End of special code that is part of the Copyright Notice             00409801
.*                                                                      00409901
.********************************************************************** 00410001
.*                                                                      00410101
.* Define variables                                                     00411000
         GBLB  &SP_SHOWALL             * Option from PGM                00420000
         GBLC  &SYSASCE                * ASC-environment: P or AR       00430000
         GBLC  &BXA_WALEN              * Worka area length              00440000
         GBLC  &BXA_ENTRY              * Entry mode                     00450000
         GBLA  &BXA_SAVES              * Nr of internal save areas      00460000
         GBLC  &BXA_WORKPTR(3)         * Pointer to work area           00470000
         GBLC  &BXA_SUBR               * Current subroutine name        00480000
         GBLC  &BXA_PGM_LABEL          * Label of CSECT from PGM macro  00490000
         GBLC  &BXA_WALAB              * Label of workarea              00500000
         LCLA  &I                      * INDEX for BXA_RETRN_...        00510000
         GBLC  &BXA_RETRN_RC(5)        * Returncodes                    00520000
         GBLC  &BXA_RETRN_RP(5)        * Return pointers                00530000
         GBLC  &BXA_RETRN_RS(5)        * Reasoncodes                    00540000
         GBLC  &BXA_RETRN_WA(5)        * WORKAREA parameters            00550000
         GBLC  &BXA_RETRN_LBL(5)       * Labels for out-of-line rout.   00560000
         GBLA  &BXA_NUMVAL             * Returnvalue from EQUREG        00580000
         LCLC  &ARG                    * Some argument                  00590000
         LCLC  &_RC                    * Returncode register            00600000
         LCLC  &_RS                    * Reasoncode register            00610000
         LCLC  &_RP                    * Return pointer register        00620000
         LCLC  &_WR1                   * Work register 1                00630000
         LCLC  &_WR2                   * Work register 2                00640000
.*                                                                      00650000
.* Check workarea parameter                                             00660000
         AIF   ('&WORKAREA' EQ 'FREE').NOERR1                           00670000
         AIF   ('&WORKAREA' EQ 'NOFREE').NOERR1A                        00680000
.ERR1A   MNOTE 8,'Workarea parameter must specify FREE or NOFREE'       00690000
         AGO   .NOERR1                                                  00700000
.NOERR1A ANOP                                                           00710000
         AIF   ('&BXA_ENTRY' EQ 'FRR').ERR1B                            00720000
         AIF   ('&BXA_ENTRY' EQ 'RESMGR').ERR1B                         00730000
         AIF   ('&BXA_ENTRY' EQ 'RMTR').ERR1B                           00740000
         AIF   ('&BXA_ENTRY' EQ 'SPCR').ERR1B                           00750000
         AIF   ('&BXA_ENTRY' EQ 'SRB').ERR1B                            00760000
         AIF   ('&BXA_ENTRY' EQ 'SVC').ERR1B                            00770000
         AGO   .NOERR1                                                  00780000
.ERR1B   MNOTE 8,'Workarea parameter must specify FREE for &BXA_ENTRY p*00790000
               rograms'                                                 00800000
.NOERR1  ANOP  ,                                                        00810000
.*                                                                      00820000
.* Check subroutine name                                                00830000
         AIF   ('&BXA_SUBR' EQ '*MAIN').NOERR2                          00840000
.ERR2    MNOTE 8,'RETRN must not be issued within a subroutine'         00850000
.NOERR2  ANOP                                                           00860000
.*                                                                      00870000
.* Check nesting level                                                  00880000
         AIF   (&SYSNEST EQ 1).NOERR3                                   00890000
         AIF   ('&INLINE' EQ 'NO').NOERR3                               00900000
.ERR3    MNOTE 8,'RETRN must not be issued from within another macro'   00910000
.NOERR3  ANOP                                                           00920000
.*                                                                      00930000
.* Check inline parameter                                               00940000
         AIF   ('&INLINE' EQ 'NO').NOERR4                               00950000
         AIF   ('&INLINE' EQ 'YES').NOERR4                              00960000
.ERR4    MNOTE 8,'INLINE parameter must specify either YES or NO'       00970000
         MEXIT                                                          00980000
.NOERR4  ANOP                                                           00990000
.*                                                                      01000000
.* Check RC parameter                                                   01010000
         AIF   (K'&RC EQ 0).NOERR5                                      01020000
         AIF   ('&BXA_ENTRY' EQ 'SRB').ERR5C                            01030000
         AIF   ('&BXA_ENTRY' EQ 'RMTR').ERR5C                           01040000
         AIF   ('&RC'(1,1) NE '(').NOERR5                               01050000
         AIF   (N'&RC NE 1).ERR5A                                       01060000
         CHKREG &RC(1),g                                                01070000
         AIF   (&BXA_RC EQ 8).ERR5B                                     01080000
         AGO   .NOERR5                                                  01090000
.ERR5A   MNOTE 4,'Only 1 register can be specified on RC, remainder ign*01100000
               ored'                                                    01110000
         AGO   .NOERR5                                                  01120000
.ERR5B   ANOP                                                           01130000
&ARG     SETC  (DOUBLE '&RC(1)')                                        01140000
         MNOTE 8,'Register &ARG is not a valid register'                01150000
         MEXIT                                                          01160000
.ERR5C   ANOP  ,                                                        01170000
         AIF   ('&RC' EQ '0').NOERR5                                    01180000
         MNOTE 8,'RC-parameter not allowed for SRB/RMTR-type routines'  01190000
.NOERR5  ANOP                                                           01200000
.*                                                                      01210000
.* Check REASON parameter                                               01220000
         AIF   (K'&REASON EQ 0).NOERR6                                  01230000
         AIF   ('&BXA_ENTRY' EQ 'FRR').ERR6C                            01240000
         AIF   ('&BXA_ENTRY' EQ 'SRB').ERR6C                            01250000
         AIF   ('&BXA_ENTRY' EQ 'RESMG').ERR6C                          01260000
         AIF   ('&BXA_ENTRY' EQ 'RMTR').ERR6C                           01270000
         AIF   ('&REASON'(1,1) NE '(').NOERR6                           01280000
         AIF   (N'&REASON NE 1).ERR6A                                   01290000
         CHKREG &REASON(1),g                                            01300000
         AIF   (&BXA_REASON EQ 8).ERR6B                                 01310000
         AGO   .NOERR6                                                  01320000
.ERR6A   MNOTE 4,'Only 1 register can be specified on REASON, remainder*01330000
                ignored'                                                01340000
         AGO   .NOERR6                                                  01350000
.ERR6B   ANOP                                                           01360000
&ARG     SETC  (DOUBLE '&REASON(1)')                                    01370000
         MNOTE 8,'Register &ARG is not a valid register'                01380000
         MEXIT                                                          01390000
.ERR6C   MNOTE 8,'REASON-parameter not allowed for &BXA_ENTRY type of r*01400000
               outine'                                                  01410000
.NOERR6  ANOP                                                           01420000
.*                                                                      01430000
.* Check RETPTR parameter                                               01440000
         AIF   (K'&RETPTR EQ 0).NOERR7                                  01450000
         AIF   ('&BXA_ENTRY' EQ 'FRR').ERR7C                            01460000
         AIF   ('&BXA_ENTRY' EQ 'SRB').ERR7C                            01470000
         AIF   ('&BXA_ENTRY' EQ 'RMTR').ERR7C                           01480000
         AIF   ('&BXA_ENTRY' EQ 'RESMGR').ERR7C                         01490000
         AIF   ('&RETPTR'(1,1) NE '(').NOERR7                           01500000
         AIF   (N'&RETPTR NE 1).ERR7A                                   01510000
         CHKREG &RETPTR(1),g                                            01520000
         AIF   (&BXA_RC EQ 8).ERR7B                                     01530000
         AGO   .NOERR7                                                  01540000
.ERR7A   MNOTE 4,'Only 1 register can be specified on RETPTR, remainder*01550000
                ignored'                                                01560000
         AGO   .NOERR7                                                  01570000
.ERR7B   ANOP                                                           01580000
&ARG     SETC  (DOUBLE '&RETPTR(1)')                                    01590000
         MNOTE 8,'Register &ARG is not a valid register'                01600000
         MEXIT                                                          01610000
.ERR7C   MNOTE 8,'RETPTR-parameter not allowed for &BXA_ENTRY type of r*01620000
               outine'                                                  01630000
.NOERR7  ANOP                                                           01640000
.*                                                                      01650000
.* INLINE-parameter determines further expansion of this macro          01660000
         AIF   ('&INLINE' EQ 'YES').INLINE                              01670000
         AIF   ('&INLINE' EQ 'NO').OUTLINE                              01680000
         MNOTE 12,'Internal error'                                      01690000
         MEXIT                                                          01700000
.*                                                                      01710000
.INLINE  ANOP                                                           01720000
&I       SETA  N'&BXA_RETRN_LBL+1      * Point firrst free element      01730000
&BXA_RETRN_LBL(&I) SETC '_RETRN&SYSNDX' * Generate label for routine    01740000
&BXA_RETRN_RC(&I)  SETC '&RC'          * Copy returncode parameter      01750000
&BXA_RETRN_RS(&I)  SETC '&REASON'      * Copy reasoncode parameter      01760000
&BXA_RETRN_RP(&I)  SETC '&RETPTR'      * Copy returnpointer parameter   01770000
&BXA_RETRN_WA(&I)  SETC '&WORKAREA'    * Copy workarea parameter        01780000
.*                                                                      01790000
.* Now replace R12 with the intended target address and branch to it    01800000
         L     R12,=AL4(_RETRN&SYSNDX) * Load out-of-line routine addr  01810000
         BR    R12                     * And execute it                 01820000
         MEXIT                                                          01830000
.*                                                                      01840000
.* Generate label if one is specified                                   01850000
.OUTLINE ANOP                                                           01860000
&LABEL   LABEL H                       * Re-align on halfword boundary  01870000
         DROP  ,                       * Drop all USINGs                01880000
         USE   &LABEL,R12              * Set code addressable           01890000
         USE   &BXA_WALAB,R13,         * Set workarea addressable      *01900000
               START=&BXA_WALAB+SAVEPRFX_LEN * upward from savearea     01910000
.*                                                                      01920000
.* We must assign 5 registers:                                          01930000
.* 1 for the returncode to be returned in R15    - &_RC                 01940000
.* 1 for the reasoncode to be returned in R0     - &_RS                 01950000
.* 1 for the return pointer to be returned in R1 - &_RP                 01960000
.* 2 work registers                              - &_WR1, &_WR2         01970000
.* Defaults are as follows:                                             01980000
.* &_RC: register specified, otherwise lowest available in range R1-R11 01990000
.* &_RS: register specified, otherwise lowest available in range R1-R11 02000000
.* &_RP: register specified, otherwise lowest available in range R1-R11 02010000
.* &_WR1,&_WR2: lowest available in range R1-R11 after assigning        02020000
.*              &_RC, &_RS, and &_RP                                    02030000
.*                                                                      02040000
.* Check which register has been assigned to the return code            02050000
         AIF   ('&RC' EQ '*').TSTRC_R15 * R15                           02060000
         AIF   ('&RC'(1,1) EQ '(').TSTRC_REG * Register                 02070000
         AGO   .TSTRC_OK               * No register to USE             02080000
.TSTRC_R15 ANOP ,                      *                                02090000
&_RC     SETC  'R15'                   * Assign R15 for returncode      02100000
         USE   R15                     * R15 contains return code       02110000
         AGO   .TSTRC_OK               *                                02120000
.TSTRC_REG ANOP ,                      *                                02130000
&_RC     SETC  '&RC(1)'                * Assign reg for returncode      02140000
         USE   &RC(1)                  * Some register contains retcd   02150000
.TSTRC_OK ANOP ,                       *                                02160000
.*                                                                      02170000
.* Check which register has been assigned to the reason code            02180000
         AIF   (K'&REASON EQ 0).TSTRS_OK * No reason code?              02190000
         AIF   ('&REASON' EQ '*').TSTRS_R0 * R0                         02200000
         AIF   ('&REASON'(1,1) EQ '(').TSTRS_REG * Register             02210000
         AGO   .TSTRS_OK               * No register to USE             02220000
.TSTRS_R0 ANOP ,                       *                                02230000
&_RS     SETC  'R0'                    * Assign R0 for reasoncode       02240000
         USE   R0                      * R0 contains reason code        02250000
         AGO   .TSTRS_OK               *                                02260000
.TSTRS_REG ANOP ,                      *                                02270000
&_RS     SETC  '&REASON(1)'            * Assign reg for reasoncode      02280000
         USE   &REASON(1)              * Some register contains reason  02290000
.TSTRS_OK ANOP ,                       *                                02300000
.*                                                                      02310000
.* Check which register has been assigned to the return pointer value   02320000
         AIF   (K'&RETPTR EQ 0).TSTRP_OK * Return pointer specified?    02330000
         AIF   ('&RETPTR' EQ '*').TSTRP_R1 * R1                         02340000
         AIF   ('&RETPTR'(1,1) EQ '(').TSTRP_REG * Register             02350000
         AGO   .TSTRP_OK               * No register to USE             02360000
.TSTRP_R1 ANOP ,                       *                                02370000
&_RP     SETC  'R1'                    * Assign R1 for returnpointer    02380000
         USE   R1                      * R1 contains return pointer     02390000
         AGO   .TSTRP_OK               *                                02400000
.TSTRP_REG ANOP ,                      *                                02410000
&_RP     SETC  '&RETPTR(1)'            * Assign reg for return pointer  02420000
         USE   &RETPTR(1)              * Some register contains retptr  02430000
.TSTRP_OK ANOP ,                       *                                02440000
.*                                                                      02450000
.* Assign two work registers (used for addressing)                      02460000
         EQUREG R0=NO                  * Find a work register           02470000
&_WR1    SETC  'R&BXA_NUMVAL'          *  create register name          02480000
         USE   &_WR1                   * and set it in use              02490000
         EQUREG R0=NO                  * And another one                02500000
&_WR2    SETC  'R&BXA_NUMVAL'          *  create register name          02510000
         USE   &_WR2                   * and set it in use              02520000
.*                                                                      02530000
.* When in access register mode, the associated ARs must be cleared     02540000
         AIF   ('&SYSASCE' NE 'AR').NOTAR                               02550000
         CLEAR A&_WR1                                                   02560000
         CLEAR A&_WR2                                                   02570000
.NOTAR   ANOP  ,                                                        02580000
.*                                                                      02590000
.* Assign register for return code (unless already valid)               02600000
         AIF   (K'&_RC GT 0)._RCREG    * Returncode in a register?      02610000
         EQUREG ,                      * No: find a register            02620000
&_RC     SETC  'R&BXA_NUMVAL'          * Create register name           02630000
         AIF   ('&RC' EQ '0').RC_0     * Set to 0                       02640000
         LA    &_RC,&RC                * Load return code into register 02650000
         USE   &_RC                    * Set register in use            02660000
         AGO   ._RCOK                                                   02670000
.RC_0    ANOP                                                           02680000
         CLEAR &_RC                    * Set returncode to zero         02690000
         USE   &_RC                    * Set register in use            02700000
         AGO   ._RCOK                                                   02710000
._RCREG  ANOP  ,                       * Check validity of register     02720000
.* For WORKAREA=FREE registers 14 thru 1 cannot be used                 02730000
         AIF   ('&WORKAREA' EQ 'NOFREE')._RCOK * Nofree: no requirement 02740000
         CHKREG &_RC,g                 * Valid register?                02750000
         AIF   (&BXA_NUMVAL LT 2).RCREG * Allocate another              02760000
         AIF   (&BXA_NUMVAL GT 13).RCREG * Allocate another             02770000
         AGO   ._RCOK                  * Reg 2-13: OK                   02780000
.RCREG   ANOP                                                           02790000
         EQUREG ,                      * No: find a register            02800000
&I       SETA  &BXA_NUMVAL             * Save new register nr           02810000
         LR    R&I,&_RC                * Copy retcd to safe register    02820000
         DROP  &_RC                    * Set register available         02830000
&_RC     SETC  'R&I'                   * Create register name           02840000
         USE   &_RC                    * And set register in use        02850000
._RCOK   ANOP                                                           02860000
.*                                                                      02870000
.* Assign register for reason code (unless already done)                02880000
         AIF   (K'&REASON EQ 0)._RSOK  * Reasoncode specified?          02890000
         AIF   (K'&_RS GT 0)._RSREG    * Reasoncode in register?        02900000
         EQUREG ,                      * No: find a register            02910000
&_RS     SETC  'R&BXA_NUMVAL'          * Create register name           02920000
         AIF   ('&REASON' EQ '0').RS_0 * Set to 0                       02930000
         LA    &_RS,&REASON            * Load reason code into register 02940000
         USE   &_RS                    * Set register in use            02950000
         AGO   ._RSOK                                                   02960000
.RS_0    ANOP                                                           02970000
         CLEAR &_RS                    * Set reasoncode to zero         02980000
         USE   &_RS                    * Set register in use            02990000
         AGO   ._RSOK                                                   03000000
._RSREG  ANOP  ,                       * Check validity of register     03010000
.* For WORKAREA=FREE registers 14 thru 1 cannot be used                 03020000
         AIF   ('&WORKAREA' EQ 'NOFREE')._RSOK * Nofree: no requirement 03030000
         CHKREG &_RS,g                 * Valid register?                03040000
         AIF   (&BXA_NUMVAL LT 2).RSREG * Allocate another              03050000
         AIF   (&BXA_NUMVAL GT 13).RSREG * Allocate another             03060000
         AGO   ._RSOK                  * Reg 2-13: OK                   03070000
.RSREG   ANOP                                                           03080000
         EQUREG ,                      * No: find a register            03090000
&I       SETA  &BXA_NUMVAL             * Save new register nr           03100000
         LR    R&I,&_RS                * Copy reason to safe register   03110000
         DROP  &_RS                    * Set register available         03120000
&_RS     SETC  'R&I'                   * Create register name           03130000
         USE   &_RS                    * And set register in use        03140000
._RSOK   ANOP                                                           03150000
.*                                                                      03160000
.* Assign register for return pointer (unless already done)             03170000
         AIF   (K'&RETPTR EQ 0)._RPOK  * Return ptr specified?          03180000
         AIF   (K'&_RP GT 0)._RPREG    * Return ptr in register?        03190000
         EQUREG ,                      * No: find a register            03200000
&_RP     SETC  'R&BXA_NUMVAL'          * Create register name           03210000
         AIF   ('&RETPTR' EQ '0').RP_0 * Set to 0                       03220000
         LA    &_RP,=AL4(&RETPTR)      * Load return ptr into register  03230000
         USE   &_RP                    * Set register in use            03240000
         AGO   ._RPOK                                                   03250000
.RP_0    ANOP                                                           03260000
         CLEAR &_RP                    * Set return pointer to zero     03270000
         USE   &_RP                    * Set register in use            03280000
         AGO   ._RPOK                                                   03290000
._RPREG  ANOP  ,                       * Check validity of register     03300000
.* For WORKAREA=FREE registers 14 thru 1 cannot be used                 03310000
         AIF   ('&WORKAREA' EQ 'NOFREE')._RPOK * Nofree: no requirement 03320000
         CHKREG &_RP,g                 * Valid register?                03330000
         AIF   (&BXA_NUMVAL LT 2).RPREG * Allocate another              03340000
         AIF   (&BXA_NUMVAL GT 13).RPREG * Allocate another             03350000
         AGO   ._RPOK                  * Reg 2-13: OK                   03360000
.RPREG   ANOP                                                           03370000
         EQUREG ,                      * No: find a register            03380000
&I       SETA  &BXA_NUMVAL             * Save new register nr           03390000
         LR    R&I,&_RP                * Copy retptr to safe register   03400000
         DROP  &_RP                    * Set register available         03410000
&_RP     SETC  'R&I'                   * Create register name           03420000
         USE   &_RP                    * And set register in use        03430000
._RPOK   ANOP                                                           03440000
.*                                                                      03450000
.* Check the internal save-areas                                        03460000
         AIF   ('&BXA_ENTRY' EQ 'SUBR' AND &BXA_SAVES EQ 0).SUBRSAV     03470000
         AIF   (&BXA_SAVES EQ 0).NOSAVES                                03480000
* All subroutines must have completed                                   03490000
         LT    &_WR1,SAVEINTF          * Retrieve ptr to internal SA's  03500000
         ABND  Z                       * If invalid: abend!             03510000
         AIF   ('&BXA_ENTRY' EQ 'SUBR').SUBRSAV                         03520000
         LT    &_WR2,SAVEINTU          * Pointer to last used is zero?  03530000
         ABND  NZ                      * No: not all subr's ended!      03540000
         AGO   .NOSAVES                * Skip SUBR logic                03550000
.*                                                                      03560000
.SUBRSAV ANOP                                                           03570000
         LT    &_WR1,SAVEINTU          * Pointer to last used is zero?  03580000
         ABND  Z                       * Yes: invalid for SUBR-type pgm 03590000
_LOOP&SYSNDX LABEL ,                                                    03600000
         DROP  &_WR2                   * Drop reg to change it          03610000
         AIF   (&BXA_SAVES EQ 0).NOSAVES                                03620000
         LR    &_WR2,&_WR1             * Point to SA on chain           03630000
SA       USE   SAVEAREA,&_WR2          * and set it addressable         03640000
         LT    &_WR1,SA.SAVENEXT       * Is there a next SA?            03650000
         BNZ   _LOOP&SYSNDX            * Yes: runchain                  03660000
         LA    &_WR1,&BXA_WALEN-SAVEAREA_LEN * Offset in dynamic area   03670000
         SR    &_WR2,&_WR1             * Point to start of area         03680000
         DROP  SA                                                       03690000
INT      USE   BXASAVE,&_WR2           * Set area addressable           03700000
         CLC   INT.SAVEID,=CL8'&BXA_PGM_LABEL' * Id is correct?         03710000
         ABND  NE                      * If not: internal error         03720000
         CLC   SAVEINTU,INT.SAVEPTSA   * all subrs ended?               03730000
         ABND  NE                      * No: must be an error!          03740000
         DROP  &_WR1                   * Drop register to change it     03750000
         L     &_WR1,INT.SAVEPREV      * Point to preceding SA on chain 03760000
PRV      USE   SAVEAREA,&_WR1          * and set it addressable         03770000
         CLEAR PRV.SAVENEXT,,XC        * Detach our subchain            03780000
         DROP  PRV                     * SAVEAREA,R4 (now end-of-chain) 03790000
         USE   &_WR1                   * Tell asm not to realloc reg.   03800000
         DROP  INT                     * BXASAVE,R5 = whole dyn.area    03810000
         USE   &_WR2                   * Tell asm not to realloc reg.   03820000
.NOSAVES ANOP                                                           03830000
.*                                                                      03840000
         AIF   ('&WORKAREA' EQ 'NOFREE').NOFREE                         03850000
         AIF   ('&BXA_ENTRY' EQ 'SUBR' AND &BXA_SAVES EQ 0).NOFREE      03860000
*                                                                       03870000
* Release dynamically allocated storage                                 03880000
         AIF   ('&BXA_ENTRY' EQ 'SUBR').WR2OK * For SUBR WR2 is ok      03890000
         DROP  &_WR2                   * Drop reg to change it          03900000
         LR    &_WR2,R13               * Copy workarea pointer          03910000
         DEC   &_WR2,SAVEPRFX_LEN      * And adjust for prefix area     03920000
.WR2OK   ANOP  ,                       *                                03930000
.*                                                                      03940000
.* If a pointer is known to exist: reset it to zeros                    03950000
         AIF   (K'&BXA_WORKPTR(3) EQ 0)._NOPTR                          03960000
* First reset pointer to zeros                                          03970000
HDR      USE   BXASAVE,&_WR2           * Set area addressable           03980000
         LT    &_WR1,HDR.SAVEPTPT      * Get ptr to area with ptr to us 03990000
         ABND  Z                       * If invalid abend program       04000000
         XC    0(4,&_WR1),0(&_WR1)     * Reset pointer to zero          04010000
         DROP  HDR                     * BXASAVE,R5 = whole dyn.area    04020000
         USE   &_WR2                   * Tell asm not to change this 1  04030000
* Then free allocated storage                                           04040000
._NOPTR  ANOP                                                           04050000
.* Free allocated storage                                               04060000
.* For SUBPGM's with FREE: Hold address of previous save-area in WR1    04070000
         AIF   ('&BXA_ENTRY' NE 'SUBPGM' AND                           *04080000
               '&BXA_ENTRY' NE 'RESMGR' AND                            *04090000
               '&BXA_ENTRY' NE 'FRR').NOSUB                             04100000
         L     &_WR1,SAVEPREV          * Save address of previous SA    04110000
.NOSUB   ANOP  ,                       *                                04120000
         AIF   ('&BXA_ENTRY' NE 'SRB' AND '&BXA_ENTRY' NE 'RMTR').NOSRB 04130000
         L     &_WR1,SAVEHDR           * Reload return address          04140000
         CLEAR SAVEHDR                 * Wipe header of save area       04150000
.NOSRB   ANOP  ,                       *                                04160000
.*                                                                      04170000
         STORAGE RELEASE,              * Free the acquired             *04180000
               ADDR=(&_WR2),           *    storage area               *04190000
               LENGTH=&BXA_WALEN       *                                04200000
.NOFREE  ANOP  ,                       *                                04210000
.*                                                                      04220000
.* Generate different code for returning to caller depending on ENTRY   04230000
         AIF   ('&BXA_ENTRY' EQ 'FRR').SUBPGM                           04240000
         AIF   ('&BXA_ENTRY' EQ 'MAIN').MAIN                            04250000
         AIF   ('&BXA_ENTRY' EQ 'RESMGR').SUBPGM                        04260000
         AIF   ('&BXA_ENTRY' EQ 'RMTR').SRB                             04270000
         AIF   ('&BXA_ENTRY' EQ 'SPCR').MAIN                            04280000
         AIF   ('&BXA_ENTRY' EQ 'SRB').SRB                              04290000
         AIF   ('&BXA_ENTRY' EQ 'SUBPGM').SUBPGM                        04300000
         AIF   ('&BXA_ENTRY' EQ 'SUBR').SUBR                            04310000
         AIF   ('&BXA_ENTRY' EQ 'SVC').SVC                              04320000
         MNOTE 12,'Internal error'                                      04330000
         MEXIT                                                          04340000
.*                                                                      04350000
.SUBPGM  ANOP                                                           04360000
*                                                                       04370000
* Set ret/reason-codes in R15/R0, restore registers, then return        04380000
.* If WORKAREA=FREE, ptr to previous SA in &_WR1                        04390000
.*        otherwise, ptr to previous SA in current SA                   04400000
         AIF   ('&WORKAREA' EQ 'FREE').FROMWR1                          04410000
         L     R13,SAVEPREV            * Point to previous SA           04420000
         AGO   .R13OK                                                   04430000
.FROMWR1 ANOP                                                           04440000
         LR    R13,&_WR1               * Restore R13 (prev.savearea)    04450000
.R13OK   ANOP                                                           04460000
         DROP  R13                     * Drop to swap using status      04470000
         USE   SAVEAREA,R13            * R13 now points to prev.SA      04480000
         L     R14,SAVEDR14            * Restore R14                    04490000
         CPY   R15,&_RC,NOWARN         * Copy returncode to R15         04500000
.* Determine how to load R0 and R1                                      04510000
&_WR2    SETC  'R2'                    * Start register for LM          04520000
         AIF   (K'&REASON GT 0 AND K'&RETPTR GT 0).SPRSRP               04530000
         AIF   (K'&REASON GT 0 AND K'&RETPTR EQ 0).SPRS                 04540000
         AIF   (K'&REASON EQ 0 AND K'&RETPTR GT 0).SPRP                 04550000
.* Neither reason nor retptr specified                                  04560000
&_WR2    SETC  'R0'                    * Reload registers 0-12          04570000
         AGO   .SP_LM                  *                                04580000
.SPRSRP  ANOP  ,                       * Both reason and retptr         04590000
         CPY   R0,&_RS,NOWARN          * Copy reasoncode to R0          04600000
         CPY   R1,&_RP,NOWARN          * Copy return ptr to R1          04610000
         AGO   .SP_LM                  *                                04620000
.SPRS    ANOP  ,                       * Only reason specified          04630000
         CPY   R0,&_RS,NOWARN          * Copy reasoncode to R0          04640000
&_WR2    SETC  'R1'                    * Reload registers 1-12          04650000
         AGO   .SP_LM                  *                                04660000
.SPRP    ANOP  ,                       * Only retptr specified          04670000
         L     R0,SAVEDR0              * Restore caller's R0            04680000
         CPY   R1,&_RP,NOWARN          * Copy return ptr to R1          04690000
.SP_LM   ANOP  ,                       *                                04700000
         LM    &_WR2,R12,SAVED&_WR2    * Restore all other registers    04710000
         BR    R14                     * Return to caller               04720000
         DROP  R13                     * SAVEAREA no longer needed      04730000
.*                                                                      04740000
         AGO   .LTORG                                                   04750000
.*                                                                      04760000
.SUBR    ANOP                                                           04770000
*                                                                       04780000
* Set return/reason-codes in R15/R0, restore registers, then return     04790000
         DROP  &_WR1                   * Drop register to change it     04800000
         L     &_WR1,SAVEINTU          * Point to last-used internal SA 04810000
SA       USE   SAVEAREA,&_WR1          * Set previous SA addressable    04820000
         MVC   SAVEINTU,SA.SAVEPREV    * Set previous SA last-used      04830000
         L     R14,SA.SAVEDR14         * Restore R14                    04840000
         CPY   R15,&_RC,NOWARN         * Copy returncode to R15         04850000
.* Determine how to load R0 and R1                                      04860000
&_WR2    SETC  'R2'                    * Start register for LM          04870000
         AIF   (K'&REASON GT 0 AND K'&RETPTR GT 0).SRRSRP               04880000
         AIF   (K'&REASON GT 0 AND K'&RETPTR EQ 0).SRRS                 04890000
         AIF   (K'&REASON EQ 0 AND K'&RETPTR GT 0).SRRP                 04900000
.* Neither reason nor retptr specified                                  04910000
&_WR2    SETC  'R0'                    * Reload registers 0-12          04920000
         AGO   .SR_LM                  *                                04930000
.SRRSRP  ANOP  ,                       * Both reason and retptr         04940000
         CPY   R0,&_RS,NOWARN          * Copy reasoncode to R0          04950000
         CPY   R1,&_RP,NOWARN          * Copy return ptr to R1          04960000
         AGO   .SR_LM                  *                                04970000
.SRRS    ANOP  ,                       * Only reason specified          04980000
         CPY   R0,&_RS,NOWARN          * Copy reasoncode to R0          04990000
&_WR2    SETC  'R1'                    * Reload registers 1-12          05000000
         AGO   .SR_LM                  *                                05010000
.SRRP    ANOP  ,                       * Only retptr specified          05020000
         L     R0,SA.SAVEDR0           * Restore caller's R0            05030000
         CPY   R1,&_RP,NOWARN          * Copy return ptr to R1          05040000
.SR_LM   ANOP  ,                                                        05050000
         LM    &_WR2,R12,SA.SAVED&_WR2 * Restore all other registers    05060000
         BR    R14                     * Return to caller               05070000
         DROP  SA                      * SAVEAREA,R4 no longer needed   05080000
         USE   &_WR1                   * Tell asm not to reallocate reg 05090000
         AGO   .LTORG                                                   05100000
.*                                                                      05110000
.MAIN    ANOP                                                           05120000
*                                                                       05130000
* Load returncode and return to caller                                  05140000
         CPY   R15,&_RC,NOWARN         * Load returncode                05150000
.* Determine how to load R0 and R1                                      05160000
         AIF   (K'&REASON GT 0 AND K'&RETPTR GT 0).MNRSRP               05170000
         AIF   (K'&REASON GT 0 AND K'&RETPTR EQ 0).MNRS                 05180000
         AIF   (K'&REASON EQ 0 AND K'&RETPTR GT 0).MNRP                 05190000
.* Neither reason nor retptr specified                                  05200000
         EREG  R0,R1                   * Reload registers 0-1           05210000
         AGO   .MN_PR                                                   05220000
.MNRSRP  ANOP  ,                       * Both reason and retptr         05230000
         CPY   R0,&_RS,NOWARN          * Copy reasoncode to R0          05240000
         CPY   R1,&_RP,NOWARN          * Copy return ptr to R1          05250000
         AGO   .MN_PR                  *                                05260000
.MNRS    ANOP  ,                       * Only reason specified          05270000
         CPY   R0,&_RS,NOWARN          * Copy reasoncode to R0          05280000
         EREG  R1,R1                   * Restore caller's R1            05290000
         AGO   .MN_PR                  *                                05300000
.MNRP    ANOP  ,                       * Only retptr specified          05310000
         EREG  R0,R0                   * Restore caller's R0            05320000
         CPY   R1,&_RP,NOWARN          * Copy return ptr to R1          05330000
.MN_PR   ANOP  ,                                                        05340000
         PR    ,                       *  and return to caller          05350000
         AGO   .LTORG                                                   05360000
.*                                                                      05370000
.SVC     ANOP                                                           05380000
*                                                                       05390000
* Load returncode and return to caller                                  05400000
         CPY   R15,&_RC,NOWARN         * Load returncode                05410000
.* Reasoncode specified for R0?                                         05420000
         AIF   (K'&REASON EQ 0).SVCNORS                                 05430000
         CPY   R0,&_RS,NOWARN          * Load reasoncode                05440000
.SVCNORS ANOP  ,                                                        05450000
.* Return pointer specified for R1?                                     05460000
         AIF   (K'&RETPTR EQ 0).SVCNORP                                 05470000
         CPY   R1,&_RP,NOWARN          * Load return pointer            05480000
.SVCNORP ANOP  ,                                                        05490000
*                                                                       05500000
* Return to caller                                                      05510000
         SVC   3                       * Pop RB                         05520000
         MEXIT ,                       *                                05530000
*                                                                       05540000
.SRB     ANOP  ,                       *                                05550000
*                                                                       05560000
* Clear retcode register and return to system                           05570000
         CPY   R15,&_RC,NOWARN         * Copy saved retcode 0           05580000
         CPY   R14,&_WR1               * Copy return register           05590000
         BR    R14                     * and return                     05600000
*                                                                       05610000
.LTORG   ANOP  ,                       *                                05620000
         LTORG ,                       * Literal pool for this routine  05630000
         DROP  ,                       * Drop all registers             05640000
.*                                                                      05650000
.MEND    MEND                                                           05660002
